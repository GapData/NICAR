{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Mapping with R\"\nauthor: \"Andrew Ba Tran\"\ndate: \"NICAR 2017\"\noutput: \n  html_document:\n    toc: true\n    toc_depth: 1\n    toc_float: true\n    theme: spacelab\n    highlight: tango\n---\n\n\nThis tutorial is an introduction to analyzing spatial data in R, specifically through making interactive locator and choropleth maps using the Leaflet package. You'll be introduced to the basics of using R as a fast and powerful command-line Geographical Information System (GIS).\n\nNo prior knowledge is necessary to follow along, but an understanding of how pipes (%>%) and dplyr works will help.\n\n**Other mapping tutorials**\n\n* Programatically generating maps and GIFs with shape files [[link](shapes-and-gifs.html)]\n* Mapping with Census data [[link](mapping-census-data.html)]\n\n# Getting started with R Leaflet\n\nSometimes it's necessary to zoom in or pan around a map for greater comprehension while exploring data spatially.\n\nThe Leaflet R package was created by the folks behind RStudio to integrate with the popular opensource Javascript library. \n\nIt’s great for journalists who have little knowledge of Javascript who want to make interesting interactives using R. And there is [excellent documentation](https://rstudio.github.io/leaflet/) if you want to dig deeper into its functionality after this introduction.\n\nEssentially, this package lets you make maps with custom map tiles, markers, polygons, lines, popups, and geojson. Almost any maps you can make in Google Fusion Tables or Carto(DB), you can make in R using the Leaflet package.\n\n```{r loading_packages, warning=F, message=F}\n# Uncomment and run \"install.packages\" functions below if you have not yet installed these packages\n\n#install.packages(\"leaflet\")\nlibrary(leaflet)\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n\n# Putting a marker on a map\n\n1. Create a map widget by calling the `leaflet()` function\n2. Add *layers* (such as features) to the map by using layer functions\n    * like `addTiles`, `addMarkers`, `addPolygons`\n3. Print the map widget\n\n```{r first_map, fig.width=8, fig.height=4, warning=F, message=F}\n# Initialize and assign m as the leaflet object\nm <- leaflet()\n# Now add tiles to it\nm <- addTiles(m)\n# Now, add a marker with a popup\nm <- addMarkers(m, lng=-81.655210, lat=30.324303, popup=\"<b>Hello</b><br><a href='http://ire.org/conferences/nicar2017/'>-NICAR 2017</a>\")\n\n# Print out the map\nm\n```\n\nSimple.\n\nBut we're going to add another function to customize the viewport zoom and center location (`setView`).\n\nAnd we're going to switch to using the *magrittr* pipe operator (`%>%`) from now on to simplify our code.\n\n```{r aside1} \n# It’s easier to wrap your head around it if you think of coding grammatically. \n\n# Normal coding in R is rigid declarative sentences: “Bob is 32. Nancy is 4 years younger than Bob.” \n\n# Coding with the pipe operator: “Nancy is 4 years younger than Bob, who is 32.” \n\n# Pipes are a comma (or a semi-colon, if you want) that lets you create one long, run-on sentence.\n```\n\n### This is the same code as above but using pipes\n\n```{r first_map_simplified,  fig.width=8, fig.height=4, warning=F, message=F}\nm <- leaflet() %>%\n  addTiles() %>%  \n  setView(-81.655210, 30.324303, zoom = 16) %>%\n  addMarkers(lng=-81.655210, lat=30.324303, popup=\"<b>Hello</b><br><a href='http://ire.org/conferences/nicar2017/'>-NICAR 2017</a>\")\n\n# See how the m object is no longer needed to be included in every line except the first? It's just assumed now.\n\nm \n```\n\nExplaining the R code\n\n* `leaflet()` initializes the leaflet workspace\n* `addTiles()` by itself will bring in the default OpenStreetMap tiles\n    * Here's [a list](http://leaflet-extras.github.io/leaflet-providers/preview/) of free leaflet tiles you can use\n    * **Note:** OpenStreetMaps is a wonderful and free open-source service. Their only stipulation for using their tiles is to be sure to credit and link to them in the map.\n* `setView()` is pretty self-explanatory but is simpler to implement\n* `addMarkers()` with some specific parameters.\n\n**Note:** The order of commands is important. A view can’t be set unless there are tiles established first.\n\n\n# How to put the map online\n\nRun the code in your RStudio console and it will appear in your Viewer tab.\n\nClick on **Export > Save as Web page**.\n\n![Export](images/export.png)\n\nGive it a filename and click save.\n\n![Save as](images/filename.png)\n\nYou have the map now as a full screen html file.\n\n\n![File](images/file.png)\n\nYou can upload the file wherever you like and then iframe to it if you want to embed it into website like the code below.\n\n`<iframe src=\"nicarmap.html\" frameborder=\"0\" width=\"100%\" height=\"300px\"></iframe>`\n\nWould produce this:\n\n<iframe src=\"nicarmap.html\" frameborder=\"0\" width=\"100%\" height=\"300px\"></iframe>\n\nOr you can leave it embedded in an RMarkdown file as the raw R code.\n\n### A note about file sizes\n\nWhen comparing the size of the HTML files, the R-produced version of the map is larger in size because it is bringing all the Javascript and CSS inline into the HTML.\n\nHowever, when looking at how much data is actually downloaded to load the map html, the differences aren’t as drastic.\n\n![Comparison](images/filesize.png)\n\nIt’s just something to keep in mind.\n\n# Multiple locations from a csv\n\nLet's bring in some new data.\n\n```{r import1}\ndunkin <- read.csv(\"data/dunkin.csv\", stringsAsFactors=F)\n\n# Bringing in the DataTables package to display the data in a nice format\nlibrary(DT)\n\n# Using the datatable function from the DT package to see the first 6 rows of data\ndatatable(head(dunkin))\n```\n\nWe've imported nearly 8,000 rows of Dunkin' Donuts store location data.\n\nLet's make a map with a new tile set.\n\nAnd this time, we'll use `addCircles` instead of `addMarkers`.\n\nSome options to use with `addCircles` includes the data to pull in for `popup` and `color`, which we've made bright orange. We've also set `radius` and `weight` and `fillOpacity`.\n\nIf we wanted to change the radius of the circle based on some datapoint, you could replace `40` with some column with numeric values in it.\n\n```{r dunk_map1, fig.width=8, fig.height=4, warning=F, messag=F}\nm <- leaflet(dunkin) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n\tattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-81.655210, 30.324303, zoom = 8) %>% \n  addCircles(~lon, ~lat, popup=dunkin$type, weight = 3, radius=40, \n                 color=\"#ffa500\", stroke = TRUE, fillOpacity = 0.8) \n\nm\n```\n\nWhy stop there?\n\nLet's bring in some competition.\n\n```{r import2}\nstarbucks <- read.csv(\"data/starbucks.csv\", stringsAsFactors=F)\n\ndatatable(head(starbucks))\n```\n\nThe data is structured a bit differently, but at least it has `type` and location data.\n\nAlso, let's switch from `addCircles` to `addCircleMarkers`.\n\n```{r dunk_map2, fig.width=8, fig.height=4, warning=F, message=F}\n# isolating just the 3 columns we're interested in-- type, lat, and lon\nsb_loc <- select(starbucks, type, lat, lon)\ndd_loc <- select(dunkin, type, lat, lon)\n\n# joining the two data frames together\nddsb <- rbind(sb_loc, dd_loc)\n\n# creating a coffee color palette\n\ncof <- colorFactor(c(\"#ffa500\", \"#13ED3F\"), domain=c(\"Dunkin Donuts\", \"Starbucks\"))\n# mapping based on type\nm <- leaflet(ddsb) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n\tattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-81.655210, 30.324303, zoom = 8) %>% \n  addCircleMarkers(~lon, ~lat, popup=ddsb$type, weight = 3, radius=4, \n                 color=~cof(type), stroke = F, fillOpacity = 0.5) \n\nm\n```\n\nPlay around with the slippy map. Interesting, right?\n\nThe file size is only 1.3 m even though there are nearly 19,000 points on the map.\n\nStill, that's a lot of points to process. It's probably making your computer fan spin.\n\n# Add a legend\n\nLet's add a legend with the function `addLegend()` and options for where to place it and colors and labels.\n\n```{r add_legend, fig.width=8, fig.height=4, warning=F, message=F}\nm <- leaflet(ddsb) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n\tattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-81.655210, 30.324303, zoom = 8) %>% \n  addCircleMarkers(~lon, ~lat, popup=ddsb$type, weight = 3, radius=4, \n                 color=~cof(type), stroke = F, fillOpacity = 0.5)  %>%\n  addLegend(\"bottomright\", colors= c(\"#ffa500\", \"#13ED3F\"), labels=c(\"Dunkin'\", \"Starbucks\"), title=\"Coffee places\")\n\n\nm\n\n```\n\n----\n\n## Mapping the end of the universe\n\n<iframe width=\"853\" height=\"480\" src=\"https://www.youtube.com/embed/Mb7qDfIzQRk\" frameborder=\"0\" allowfullscreen></iframe>\n\nAccording to comedian Lewis Black, the End of the Universe is in Houston, where there's a Starbucks across the street from another Starbucks.\n\nLet's see if this is true and let's look for 10 in all.\n\nHere's another loop and instead of comparing SB locations to Dunkin locations, we'll compare SB locations to other SB locations.\n\nLike before, the code to do so is below, but you can skip ahead to the next chunk if you don't want to wait ~2 hours for the data to process and loop.\n\n```{r looper2, eval=F}\n# Creating a loop to go through the Starbucks dataframe and compare it itself\n# Going through each row of SB lat and lon and finding/keeping the SB lat/lon with the shortest distance to it\n\n# First, set up some temp columns\nsb_loc$sb_lat <- 0\nsb_loc$sb_lon <- 0\nsb_loc$feet <- 0\nsb_loc$string_check <- paste(sb_loc$lat, sb_loc$lon)\n\n# Now the loop\nfor (i in 1:nrow(sb_loc)) {\n  print(paste0(i, \" of \", nrow(sb_loc)))\n# Looping through the SB dataframe\n\n  # slicing out each row\n  sb_loc_row <- subset(sb_loc[i,])\n  \n  # Filtering out the sliced out row so it doesn't measure against itself\n  sb_loc_compare <- subset(sb_loc, string_check!=sb_loc_row$string_check[1])\n  \n  # Looping through the new SB dataframe\n  for (x in 1:nrow(sb_loc_compare)) {\n\n    # Using the spDistsN1 function which is a little weird because it\n    #  only works if the lat lon pairs being measured are in a matrix\n    to_measure_sb <- matrix(c(sb_loc_row$lon[1], sb_loc_compare$lon[x], sb_loc_row$lat[1], sb_loc_compare$lat[x]), ncol=2)\n    # Comparing the entire matrix to a single row in the matrix\n    km <- spDistsN1(to_measure_sb, to_measure_sb[1,], longlat=TRUE)\n    # We only care about the second result sine the first result is always zero\n    km <- km[2]\n    \n    # Converting kilometers to feet\n    feet <- round(km*1000/.3048,2)\n    \n    # These if statements replace the current SB lat and lon and feet variables \n    #  with the first results but replaces that if\n    #  the feet value is smaller than what's currently in it\n    if (x==1) {\n      sb_loc_row$sb_lat <- sb_loc_compare$lat[x]\n      sb_loc_row$sb_lon <- sb_loc_compare$lon[x]\n      sb_loc_row$feet <- feet\n      sb_loc_row$sb_name <- sb_loc_compare$string_check[x]\n    } else {\n      if (feet < sb_loc_row$feet) {\n        sb_loc_row$sb_lat <- sb_loc_compare$lat[x]\n        sb_loc_row$sb_lon <- sb_loc_compare$lon[x]\n        sb_loc_row$feet <- feet\n        sb_loc_row$sb_name <- sb_loc_compare$string_check[x]\n        }\n    }\n  }\n  \n  # This is rebuilding the dataframe row by row with the new SB dataframe values\n  if (i==1) {\n    sb_distances <- sb_loc_row\n  } else {\n    sb_distances <- rbind(sb_distances, sb_loc_row)\n  }\n}\n\n# sb_distances <- unique...\nwrite.csv(sb_distances, \"data/sb_distances.csv\")\n```\n\nAlright, map it.\n\n\n\n```{r filter_and_map2, fig.width=8, fig.height=5, message=F, warning=F}\n# Bringing in the dataframe because I don't want to make you wait through a loop\nsb_distances <- read.csv(\"data/sb_distances.csv\")\n\n# Arranging and filtering just the 10 locations with the shortest distances\nsb_10 <- sb_distances %>%\n  arrange(feet) %>%\n  filter(feet > 60) %>%\n  head(40)\n\nsb_solo <- select(sb_10, lat, lon, feet)\nsb_solo2 <- select(sb_10, sb_lat, sb_lon, feet)\ncolnames(sb_solo2) <- c(\"lat\", \"lon\", \"feet\")\n\nsb_again <- rbind(sb_solo, sb_solo2)\n\n# Mapping it\nm <- leaflet(sb_again) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n\tattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addCircleMarkers(~lon, ~lat, popup=sb_again$feet, weight = 3, radius=4, \n                 color=\"#13ED3F\", stroke = F, fillOpacity = 0.5)  %>%\n  addLegend(\"bottomright\", colors= \"#13ED3F\", labels=\"Starbucks\", title=\"End of the Universe\")\n\n\nm\n```\n\n# Making choropleths\n\nTo make a choropleth map, you first need a shapefile or geojson of the polygons that you're filling in. \n\n# Importing shapefiles from the Census\n\nYou could download and import the shapefile into R [yourself](file:///Users/andrewtran/Documents/Github/nicar-2017/maps/mapping-census-data.html), but there's a package that brings in Census shapefiles for you called [**Tigris**](https://github.com/walkerke/tigris).\n\nThis is what the U.S. states looks like on in leaflet R.\n\n```{r choropleth1, fig.width=8, fig.height=4, warning=F, message=F}\n# Polygon stuff from shape file\n# install.packages(\"tigris\")\nlibrary(tigris)\n\nstates <- states(cb=T)\n\n# Let's quickly map that out\nstates %>% leaflet() %>% addTiles() %>% addPolygons(popup=~NAME)\n\n```\n\nThis is how it looks raw. The Census shape files also include territories.\n\nWhen mapping, we'll have to remember to exclude them if they show up.\n\n# Joining data to a shapefile\n\n### Let's make a choropleth map based on number of Starbucks per state\n\n```{r sb_chor, fig.width=8, fig.height=4, warning=F, message=F}\n# First, we'll use dplyr to summarize the data\n# count by state\nsb_state <- starbucks %>%\n  group_by(Province) %>%\n  summarize(total=n())\n\n# Some quick adjustments to the the dataframe to clean up names\nsb_state$type <- \"Starbucks\"\ncolnames(sb_state) <- c(\"state\", \"total\", \"type\")\n\n# Now we use the Tigris function geo_join to bring together \n# the states shapefile and the sb_states dataframe -- STUSPS and state \n# are the two columns they'll be joined by\nstates_merged_sb <- geo_join(states, sb_state, \"STUSPS\", \"state\")\n\n# Creating a color palette based on the number range in the total column\npal <- colorNumeric(\"Greens\", domain=states_merged_sb$total)\n\n# Getting rid of rows with NA values\nstates_merged_sb <- subset(states_merged_sb, !is.na(total))\n\n# Setting up the pop up text\npopup_sb <- paste0(\"Total: \", as.character(states_merged_sb$total))\n\n# Mapping it with the new tiles CartoDB.Positron\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addPolygons(data = states_merged_sb , \n              fillColor = ~pal(states_merged_sb$total), \n              fillOpacity = 0.7, \n              weight = 0.2, \n              smoothFactor = 0.2, \n              popup = ~popup_sb) %>%\n  addLegend(pal = pal, \n            values = states_merged_sb$total, \n            position = \"bottomright\", \n            title = \"Starbucks\")\n\n```\n\nHmm... Not that interesting, right?\n\nWhat's the problem here. You know what's wrong.\n\nThis is essentially a population map.\n\nSo we need to adjust for population.\n\nAnd that's easy to do using the Census API.\n\n# Bringing in Census data via API\n\nWe'll use the [censusapi](https://github.com/hrecht/censusapi) package created by journalist Hannah Recht. \n\n```{r census_api}\n# install.packages(\"devtools\")\n# devtools::install_github(\"hrecht/censusapi\")\n\nlibrary(censusapi)\n\n# Pulling in the key.R script that has my census api key. \n# It will be disabled after this weekend so get your own\n# http://api.census.gov/data/key_signup.html\n\nsource(\"key.R\") \n\n# We won't go over all the functions, but uncomment the lines below to see \n# the available variables \n# vars2015 <- listCensusMetadata(name=\"acs5\", vintage=2015, \"v\")\n# View(vars2015)\n\n# Alright, getting total population by state from the API\nstate_pop <-  getCensus(name=\"acs5\", \n                        vintage=2015,\n                        key=census_key, \n                        vars=c(\"NAME\", \"B01003_001E\"), \n                        region=\"state:*\")\n\ndatatable(head(state_pop))\n\n# Cleaning up the column names\ncolnames(state_pop) <- c(\"NAME\", \"state_id\", \"population\")\nstate_pop$state_id <- as.numeric(state_pop$state_id)\n# Hm, data comes in numbers of fully spelled out, not abbreviations\n\n# Did you know R has its own built in list of State names and State abbreviations?\n# Just pull it in this way to create a dataframe for reference\n\nstate_off <- data.frame(state.abb, state.name)\n\n# So I needed to create the dataframe above because the Census API data \n# gave me states with full names while the Starbucks data came with abbreviated state names\n# So I needed a relationship dataframe so I could join the two\n\n# Cleaning up the names for easier joining\ncolnames(state_off) <- c(\"state\", \"NAME\")\n\n# Joining state population dataframe to relationship file\nstate_pop <- left_join(state_pop, state_off)\n\n# The relationship dataframe didnt have DC or Puerto Rico, so I'm manually putting those in\nstate_pop$state <- ifelse(state_pop$NAME==\"District of Columbia\", \"DC\", as.character(state_pop$state))\nstate_pop$state <- ifelse(state_pop$NAME==\"Puerto Rico\", \"PR\", as.character(state_pop$state))\n\n# Joining Starbucks dataframe to adjusted state population dataframe\nsb_state_pop <- left_join(sb_state, state_pop)\n\n# Calculating per Starbucks stores 100,000 residents and rounding to 2 digits\nsb_state_pop$per_capita <- round(sb_state_pop$total/sb_state_pop$population*100000,2)\n\n# Eliminating rows with NA\nsb_state_pop <- subset(sb_state_pop, !is.na(per_capita))\ndatatable(head(sb_state_pop))\n```\n\n# Final map\n\n```{r leaflet_choropleth, fig.width=8, fig.height=4, warning=F, message=F}\nstates_merged_sb_pc <- geo_join(states, sb_state_pop, \"STUSPS\", \"state\")\n\npal_sb <- colorNumeric(\"Greens\", domain=states_merged_sb_pc$per_capita)\nstates_merged_sb_pc <- subset(states_merged_sb_pc, !is.na(per_capita))\n\npopup_sb <- paste0(\"Per capita: \", as.character(states_merged_sb_pc$per_capita))\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addPolygons(data = states_merged_sb_pc , \n              fillColor = ~pal_sb(states_merged_sb_pc$per_capita), \n              fillOpacity = 0.9, \n              weight = 0.2, \n              smoothFactor = 0.2, \n              popup = ~popup_sb) %>%\n  addLegend(pal = pal_sb, \n            values = states_merged_sb_pc$per_capita, \n            position = \"bottomright\", \n            title = \"Starbucks<br />per 100,000<br/>residents\")\n```\n\n---\n\n# Final map II\n\nThe Leaflet for R package was recently updated, adding functionality like highlighting polygons and labels on hover.\n\nThis options include `highlight` and `labelOptions `. [Read more](https://rstudio.github.io/leaflet/choropleths.html) at rstudio.\n\n```{r leaflet_choropleth2, fig.width=8, fig.height=4, warning=F, message=F}\nstates_merged_sb_pc <- geo_join(states, sb_state_pop, \"STUSPS\", \"state\")\n\npal_sb <- colorNumeric(\"Greens\", domain=states_merged_sb_pc$per_capita)\nstates_merged_sb_pc <- subset(states_merged_sb_pc, !is.na(per_capita))\n\npopup_sb <- paste0(\"Per capita: \", as.character(states_merged_sb_pc$per_capita))\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addPolygons(data = states_merged_sb_pc , \n              fillColor = ~pal_sb(states_merged_sb_pc$per_capita), \n              fillOpacity = 0.9, \n              weight = 0.2, \n              smoothFactor = 0.2,\n              highlight = highlightOptions(\n                  weight = 5,\n                  color = \"#666\",\n                  dashArray = \"\",\n                  fillOpacity = 0.7,\n                   bringToFront = TRUE),\n              label=popup_sb,\n              labelOptions = labelOptions(\n    style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n    textsize = \"15px\",\n    direction = \"auto\")) %>%\n  addLegend(pal = pal_sb, \n            values = states_merged_sb_pc$per_capita, \n            position = \"bottomright\", \n            title = \"Starbucks<br />per 100,000<br/>residents\")\n```",
    "created" : 1488241609137.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1297300855",
    "id" : "7538F685",
    "lastKnownWriteTime" : 1487992802,
    "last_content_update" : 1487992802,
    "path" : "~/Documents/Github/NICAR/2017/maps/leaflet-r.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}