{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Mapping with R\"\nauthor: \"Andrew Ba Tran\"\ndate: \"NICAR 2017\"\noutput: \n  html_document:\n    toc: true\n    toc_depth: 1\n    toc_float: true\n    theme: spacelab\n    highlight: tango\n---\n\nThis tutorial is an introduction to analyzing spatial data in R, specifically through map-making with R's 'base' graphics and ggplot2 for static maps. You'll be introduced to the basics of using R as a fast and powerful command-line Geographical Information System (GIS). We'll also use the really fun Census API package. Seriously, it is a life-changer. \n\nNo prior knowledge is necessary to follow along, but an understanding of how pipes (%>%) and dplyr works will help.\n\n**Other mapping tutorials**\n\n* Programatically generating maps and GIFs with shape files [[link](shapes-and-gifs.html)]\n* Interactive maps with Leaflet in R [[link](leaflet-r.html)]\n\n\n# Geolocating addresses in R\n\n\nWe're going to start with geolocating municipal police stations in Connecticut.\n\nWe'll be using the [`ggmap` package](https://github.com/dkahle/ggmap) for a lot of functions, starting with geolocating addresses with Google Maps.\n\n```{r loading_packages, warning=F, message=F}\nlibrary(tidyverse)\nlibrary(ggmap)\nlibrary(DT)\nlibrary(knitr)\n```\n\n```{r geolocating}\nstations <- read.csv(\"data/Police_Departments.csv\", stringsAsFactors=F)\ndatatable(head(stations))\n```\n\n----\n\nWe need a single column for addresses, so we'll concatenate a few columns.\n\n```{r geolocating2, eval=F}\nstations$location <- paste0(stations$ADDRESS, \", \", stations$CITY, \", CT \", stations$ZIP)\n\n# This function geocodes a location (find latitude and longitude) using the Google Maps API\ngeo <- geocode(location = stations$location, output=\"latlon\", source=\"google\")\n```\n\n```{r geo}\n# If it's taking too long, you can cancel and load the output by uncommenting the line below\ngeo <- read.csv(\"data/geo_stations.csv\")\n\n# Bringing over the longitude and latitude data\nstations$lon <- geo$lon\nstations$lat <- geo$lat\n```\n\n# Shapefiles with ggplot2\n\nWe could plot the points using leaflet and with shapefiles brought in via the Tigris package, but we'll do it the old-fashioned way.\n\nFirst, we'll bring in our own shapefile and plot it as a static image.\n\nWe need to put all our shapefiles in a directory we can find later.\n\n![map_shapes folder](images/folder.png)\n\nThe working directory is `maps` and I've placed the **ctgeo** shapefiles into the `map_shapes` folder.\n\nNow, I can load it in with the `readOGR` function and display it with `plot()`.\n\nFirst, we'll need to load the [`rgdal` package](https://cran.r-project.org/web/packages/rgdal/rgdal.pdf).\n\n```{r geo_map_basic, fig.width=8, fig.height=4, warning=F, message=F}\n# install.packages(rgdal)\nlibrary(rgdal)\n\n# dsn is the folder the shape files are in. layer is the name of the file.\ntowns <- readOGR(dsn=\"map_shapes\", layer=\"ctgeo\")\n\nplot(towns)\n```\n\n----\n\nSimple.\n\nNow, let's add the police station locations as a layer using `plot()` again but identifying the color this time using `add=TRUE`.\n\n# Converting to spatial points\n\n\n```{r geo_map_basic_points, fig.width=8, fig.height=4, warning=F, message=F}\n# first, we have to isolate the coordinates of the police stations\n# and let R know that these are spatial points\n\ncoords <- stations[c(\"lon\", \"lat\")]\n\n# Making sure we are working with rows that don't have any blanks\ncoords <- coords[complete.cases(coords),]\n\n# Letting R know that these are specifically spatial coordinates\nsp <- SpatialPoints(coords)\n\n\nplot(towns)\nplot(sp, col=\"red\", add=TRUE)\n```\n\nCongrats, this is the **base** method of plotting spatial data.\n\nBut we're going to try it with ggplot2 because there are nice and easy features with it.\n\n# Plotting points with ggplot2\n\n```{r plotting_ggplot2, fig.width=8, fig.height=4, warning=F, message=F}\n# First, ggplot2 works with dataframes\n# So, we need to convert the towns shapefile into a dataframe with the fortify function\n# Also, we'll make sure the region option is set to a unique name column if we want to join data later\n\ntowns_fortify <- fortify(towns, region=\"NAME10\")\n\ngg <- ggplot()\ngg <- gg + geom_polygon(data=towns_fortify, aes(x=long, y=lat, group=group, fill=NA), color = \"black\", fill=NA, size=0.5) \ngg <- gg + geom_point(data=stations, aes(x=lon, y=lat, color=\"red\"))\ngg <- gg +  coord_map()\ngg\n```\n\n----\n\n# Styling maps with ggplot2\n\nAlright, let's clean it up a bit.\n\nWe don't need the grid or the background or the axis or even the legend.\n\nWe also need a headline and source.\n\n\n```{r plotting_ggplot3, fig.width=8, fig.height=5, warning=F, message=F}\ngg <- ggplot()\ngg <- gg + geom_polygon(data=towns_fortify, aes(x=long, y=lat, group=group, fill=NA), color = \"black\", fill=NA, size=0.5) \ngg <- gg + geom_point(data=stations, aes(x=lon, y=lat, color=\"red\"))\ngg <- gg +  coord_map()\ngg <- gg + labs(x=NULL, y=NULL, \n                  title=\"Police stations in Connecticut\",\n                  subtitle=NULL,\n                  caption=\"Source: data.ct.gov\")\n  gg <- gg + theme(plot.title=element_text(face=\"bold\", family=\"Arial\", size=13))\n  gg <- gg + theme(plot.caption=element_text(face=\"bold\", family=\"Arial\", size=7, color=\"gray\", margin=margin(t=10, r=80)))\n  gg <- gg + theme(legend.position=\"none\")\n  gg <- gg + theme(axis.line =  element_blank(),\n                   axis.text =  element_blank(),\n                   axis.ticks =  element_blank(),\n                   panel.grid.major = element_blank(),\n                   panel.grid.minor = element_blank(),\n                   panel.border = element_blank(),\n                   panel.background = element_blank()) \nprint(gg)\n```\n\nFrom here, you could export this as a **png** or **svg** and edit it further with Adobe Illustrator.\n\nTo do so, use the command `ggsave(file=\"filename.svg\", plot=gg, width=10, height=8)`\n\nBut let's move on and look at traffic stops that police conducted in a single town: Hamden.\n\nLet's plot out the stops in relation to the Census tracts of the town.\n\n```{r stops_import, warning=F, message=F}\n# Bring in the data\nstops <- read.csv(\"data/hamden_stops.csv\", stringsAsFactors=FALSE)\n```\n\nThere were nearly 5,500 traffic stops in Hamden in 2015. \n\n----\n\n![This data set has 50 columns of variables, including race and age.](images/stops.png)\n\n----\n\n```{r traffic_stops_hamden_points, fig.width=8, fig.height=5, warning=F, message=F}\n\n# Check and eliminate the rows that don't have location information \nstops <- stops[!is.na(stops$InterventionLocationLatitude),]\nstops <- subset(stops, InterventionLocationLatitude!=0)\n\n# Bring in the shape files for census tracts\n\n# map_shapes is the folder the shape files are in. layer is the name of the file.\ntowntracts <- readOGR(dsn=\"map_shapes\", layer=\"hamden_census_tracts\")\n\n# creating a copy\ntowntracts_only <- towntracts\n\n# turn the shapefile into a dataframe that can be worked on in R\n\ntowntracts <- fortify(towntracts, region=\"GEOID10\")\n\n# So now we have towntracts and towntracts_only\n# What's the difference? towntracts is a dataframe and can be seen easily\n\ngg <- ggplot()\ngg <- gg + geom_polygon(data=towntracts, aes(x=long, y=lat, group=group, fill=NA), color = \"black\", fill=NA, size=0.5) \ngg <- gg + geom_point(data=stops, aes(x=InterventionLocationLongitude, y=InterventionLocationLatitude, color=\"red\"))\ngg <- gg +  coord_map()\ngg <- gg + labs(x=NULL, y=NULL, \n                  title=\"Traffic stops in Hamden\",\n                  subtitle=NULL,\n                  caption=\"Source: data.ct.gov\")\n  gg <- gg + theme(plot.title=element_text(face=\"bold\", family=\"Arial\", size=13))\n  gg <- gg + theme(plot.caption=element_text(face=\"bold\", family=\"Arial\", size=7, color=\"gray\", margin=margin(t=10, r=80)))\n  gg <- gg + theme(legend.position=\"none\")\n  gg <- gg + theme(axis.line =  element_blank(),\n                   axis.text =  element_blank(),\n                   axis.ticks =  element_blank(),\n                   panel.grid.major = element_blank(),\n                   panel.grid.minor = element_blank(),\n                   panel.border = element_blank(),\n                   panel.background = element_blank()) \nprint(gg)\n\n\n```\n\n----\n\n# Deeper analysis\n\nIf you have a data set with latitude and longitude information, it’s easy to just throw it on a map with a dot for every instance. \n\nBut what would that tell you? You see the intensity of the cluster of dots over the area but that’s it. \n\nIf there’s no context or explanation it’s a flashy visualization and that’s it.\n\n# Heat map\n\nOne way is to visualize the distribution of stops.\n\nWe'll use the `stat_density2d` function within ggplot2 and use `coord_map` and `xlim` and `ylim` to set the boundaries on the map so it's zoomed in more.\n\n```{r density1, fig.width=8, fig.height=5, warning=F, message=F}\n\ngg <- ggplot()\ngg <- gg + stat_density2d(data=stops, show.legend=F, aes(x=InterventionLocationLongitude, y=InterventionLocationLatitude, fill=..level.., alpha=..level..), geom=\"polygon\", size=2, bins=10)\ngg <- gg + geom_polygon(data=towntracts, aes(x=long, y=lat, group=group, fill=NA), color = \"black\", fill=NA, size=0.5) \ngg <- gg + scale_fill_gradient(low=\"deepskyblue2\", high=\"firebrick1\", name=\"Distribution\")\ngg <- gg +  coord_map(\"polyconic\", xlim=c(-73.067649, -72.743739), ylim=c(41.280972, 41.485011)) \ngg <- gg + labs(x=NULL, y=NULL, \n                  title=\"Traffic stops distribution in Hamden\",\n                  subtitle=NULL,\n                  caption=\"Source: data.ct.gov\")\ngg\n```\n\nThat's interesting.\n\nWhat's nice about ggplot2, is the functionality called facets, which allows the construction of small multiples based on factors.\n\nLet's try this again but faceted by race.\n\n\n\n```{r density2, fig.width=8, fig.height=5, warning=F, message=F}\n# Cleaning up for Hispanic distinction\nstops$race <- ifelse(stops$SubjectEthnicityCode==\"H\", \"H\", stops$SubjectRaceCode)\n  \ngg <- ggplot()\ngg <- gg + stat_density2d(data=stops, show.legend=F, aes(x=InterventionLocationLongitude, y=InterventionLocationLatitude, fill=..level.., alpha=..level..), geom=\"polygon\", size=2, bins=10)\ngg <- gg + geom_polygon(data=towntracts, aes(x=long, y=lat, group=group, fill=NA), color = \"black\", fill=NA, size=0.5) \ngg <- gg + scale_fill_gradient(low=\"deepskyblue2\", high=\"firebrick1\", name=\"Distribution\")\ngg <- gg +  coord_map(\"polyconic\", xlim=c(-73.067649, -72.743739), ylim=c(41.280972, 41.485011)) \n\n# This is the line that's being added\ngg <- gg + facet_wrap(~race)\ngg <- gg + labs(x=NULL, y=NULL, \n                  title=\"Traffic stops distribution in Hamden by race\",\n                  subtitle=NULL,\n                  caption=\"Source: data.ct.gov\")\ngg\n```\n\nInteresting. \n\nBut it still doesn't tell the full story because it's still a bit misleading.\n\nHere's what I mean.\n\n```{r table}\ntable(stops$race)\n```\n\nThe distribution is comparitive to its own group and not as a whole.\n\nGotta go deeper.\n\nLet's look at which neighborhoods police tend to pull people over more often and compare it to demographic data from the Census.\n\nSo we need to count up the instances with the `over()` function.\n\n# Points in a polygon \n\n```{r points_in_a_polygon, warning=F, message=F}\n# We only need the columns with the latitude and longitude\ncoords <- stops[c(\"InterventionLocationLongitude\", \"InterventionLocationLatitude\")]\n\n# Letting R know that these are specifically spatial coordinates\nsp <- SpatialPoints(coords)\n\n# Applying projections to the coordinates so they match up with the shapefile we're joining them with\n# More projections information http://trac.osgeo.org/proj/wiki/GenParms \nproj4string(sp) <- \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\nproj4string(sp)\n\n\n# Calculating points in a polygon\n# Using the over function, the first option is the points and the second is the polygons shapefile\nby_tract <- over(sp, towntracts_only)\n\ndatatable(by_tract)\n\n```\n\n----\n\nWhat just happened: Every point in the original stops list now has a corresponding census tract.\n\nNow, we can summarize the data by count and merge it back to the shape file and visualize it.\n\n```{r points_in_a_polygon2, warning=F, message=F}\n\nby_tract <- by_tract %>%\n  group_by(GEOID10) %>%\n  summarise(total=n())\n\n# Get rid of the census tracts with no data\nby_tract <- by_tract[!is.na(by_tract$GEOID10),]\n\nkable(head(by_tract,5))\n\n# Rename the columns of this datframe so it can be joined to future data\ncolnames(by_tract) <- c(\"id\", \"total\")\n\n# Changing the GEOID number to character so it can be joined to future data\nby_tract$id <- as.character(by_tract$id)\n```\n\n----\n\nAlright, we have the tract ID, but we need to bring in a relationship file that matches a census tract ID to town names (because Hamden police sometimes stopped people outside of city limits).\n\n----\n\n```{r knitr}\nlibrary(knitr)\n# Bring in a dataframe that has matches census tract ID numbers to town names\ntracts2towns <- read.csv(\"data/tracts_to_towns.csv\", stringsAsFactors=FALSE)\n\nkable(head(tracts2towns, 5))\n\n\n# Changing the column names so it can be joined to the by_tract dataframe\ncolnames(tracts2towns) <- c(\"id\", \"town_name\")\n\n# Changing the GEOID number to character so it can be joined to the by_tract dataframe\ntracts2towns$id <- as.character(tracts2towns$id)\n\n# Adding a 0 to the front of the GEOID string because it was originally left out when it was imported\ntracts2towns$id <- paste0(\"0\", tracts2towns$id)\n\n# Bringing in a library to deal with strings\nlibrary(stringr)\n\n# Eliminating leading and trailing white space just in case\ntracts2towns$town_name <- str_trim(tracts2towns$town_name)\n\n# Joining the by_tract dataframe to the tracts2towns dataframe\n\nby_tract <- left_join(by_tract, tracts2towns)\n```\n\n----\n\nThat was a lot of work, but now we can tell for sure when Hamden police overextended themselves.\n\n# Making a choropleth\n\nA choropleth map is a thematic map in which areas are shaded or patterned in proportion to the measurement of the statistical variable being displayed on the map. In this instance, it’s total traffic stops.\n\nWe'll use the [`scales` package](https://cran.r-project.org/web/packages/scales/scales.pdf) for simplified color schemes.\n\n```{r choropleth1, fig.width=8, fig.height=5, warning=F, message=F}\n# Join the by_tract points to polygon dataframe to the original census tracts dataframe\ntotal_map <- left_join(towntracts, by_tract)\n\nlibrary(scales)\n\nhamden_ts <- ggplot() \nhamden_ts <- hamden_ts +  geom_polygon(data = total_map, aes(x=long, y=lat, group=group, fill=total), color = \"black\", size=0.2) \nhamden_ts <- hamden_ts + geom_polygon(data = total_map, aes(x=long, y=lat, group=group, fill=total), color = \"black\", size=0.2) \nhamden_ts <- hamden_ts + coord_map() \nhamden_ts <- hamden_ts + scale_fill_distiller(type=\"seq\", trans=\"reverse\", palette = \"Reds\", breaks=pretty_breaks(n=10)) \nhamden_ts <- hamden_ts + theme_nothing(legend=TRUE) \nhamden_ts <- hamden_ts + labs(title=\"Where Hamden police conduct traffic stops\", fill=\"\")\nprint(hamden_ts)\n\n```\n\n----\n\nExcellent. This is a great start but we have a lot of gray tracts.\n\nLet’s try again but without the gray.\n\n```{r choropleth2, fig.width=8, fig.height=5, warning=F, message=F}\n\n# Filter out the tracts with NA in the total column\n\ntotal_map <- subset(total_map, !is.na(total))\n\nhamden_ts <- ggplot() \nhamden_ts <- hamden_ts +  geom_polygon(data = total_map, aes(x=long, y=lat, group=group, fill=total), color = \"black\", size=0.2)\nhamden_ts <- hamden_ts +  coord_map()\nhamden_ts <- hamden_ts +  scale_fill_distiller(type=\"seq\", trans=\"reverse\", palette = \"Reds\", breaks=pretty_breaks(n=10))\nhamden_ts <- hamden_ts +  theme_nothing(legend=TRUE)\nhamden_ts <- hamden_ts +  labs(title=\"Where Hamden police conduct traffic stops\", fill=\"\")\nprint(hamden_ts)\n\n\n```\n\n----\n\nMuch better. But we’re still unclear which part is Hamden and which are parts of other towns.\n\nWe need to bring in an additional shape file— town borders.\n\n```{r town_borders, fig.width=8, fig.height=5, warning=F, message=F}\n# bringing in another shape file of all connecticut towns\ntownborders <- readOGR(dsn=\"map_shapes\", layer=\"ctgeo\")\ntownborders_only <- townborders\ntownborders<- fortify(townborders, region=\"NAME10\")\n\n# Subset the town borders to just Hamden since that's the department we're looking at\ntown_borders <- subset(townborders, id==\"Hamden\")\n\nhamden_ts <- ggplot() \nhamden_ts <- hamden_ts +  geom_polygon(data = total_map, aes(x=long, y=lat, group=group, fill=total), color = \"black\", size=0.2) \nhamden_ts <- hamden_ts +  geom_polygon(data = town_borders, aes(x=long, y=lat, group=group, fill=total), color = \"black\", fill=NA, size=0.5) \nhamden_ts <- hamden_ts +  coord_map() \nhamden_ts <- hamden_ts +  scale_fill_distiller(type=\"seq\", trans=\"reverse\", palette = \"Reds\", breaks=pretty_breaks(n=10)) \nhamden_ts <- hamden_ts +  theme_nothing(legend=TRUE) \nhamden_ts <- hamden_ts +  labs(title=\"Where Hamden police conduct traffic stops\", fill=\"\")\nprint(hamden_ts)\n\n```\n\nThat additional line of `geom_polygon()` code layered on the Hamden town borders. \n\nSo now we can see which tracts fell outside.\n\n# Analyzing the data\n\nBefore we move on, we need to also calculate the number of minority stops in Hamden census tracts.\n\n```{r analysis}\n# Add a column to original stops dataset identifying a driver as white or a minority\nstops$ethnicity <- ifelse(((stops$SubjectRaceCode ==  \"W\") & (stops$SubjectEthnicityCode ==\"N\")), \"White\", \"Minority\")\n\n# Create a dataframe of only minority stops\ncoords <- subset(stops, ethnicity==\"Minority\")\ncoords <- coords[c(\"InterventionLocationLongitude\", \"InterventionLocationLatitude\")]\ncoords <- coords[complete.cases(coords),]\nsp <- SpatialPoints(coords)\nproj4string(sp) <- \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\nproj4string(sp)\n\n# Points in a polygon for minorities who were stopped\nm_tract <- over(sp, towntracts_only)\n\nm_tract <- m_tract %>%\n  group_by(GEOID10) %>%\n  summarise(minority=n())\n\nm_tract <- m_tract[!is.na(m_tract$GEOID10),]\ncolnames(m_tract) <- c(\"id\", \"minority\")\nm_tract$id <- as.character(m_tract$id)\n\njoined_tracts <- left_join(by_tract, m_tract)\n\n# Calculating percent of stops that were minorities\n\njoined_tracts$minority_p <- round(joined_tracts$minority/joined_tracts$total*100,2)\n```\nTo summarize the code above, we ran the over() function once more, but to a subset of the stops data that was specifically of minority drivers.\n\nThen we figured out the percent of minority drivers stopped per census tract.\n\nHere's a sample of the results.\n\n```{r kable_table, warning=F, message=F}\nkable(head(joined_tracts))\n```\n\n----\n\n# Joining with census data\n\nWe’ll be using the [censusapi](https://github.com/hrecht/censusapi) package from Hanna Recht. It has excellent [documentation](http://urbaninstitute.github.io/R-Trainings/accesing-census-apis/presentation/index.html).\n\n```{r census_api, warning=F, message=F}\n# If you do not yet have the censusapi package installed, uncomment the lines below and run them.\n\n#install.packages(\"devtools\")\n#devtools::install_github(\"hrecht/censusapi\")\nlibrary(\"censusapi\")\n\n# Loading my census key from an external script\nsource(\"key.R\")\n\n# Replace census_key below with \"your_own_key_whatever_it_is\"\n# Apply for one here http://api.census.gov/data/key_signup.html\n\nrace_tracts <- getCensus(name=\"acs5\",\n    vintage=2014,\n    key=census_key,\n    vars=c(\"NAME\", \"B02001_001E\", \"B02001_002E\"),\n    region=\"tract:*\", regionin=\"state:09\")\n\nkable(head(race_tracts))\n```\n\n----\n\n### What did we just do?\n\nWe pulled the following population data for all census tracts in state 09, which is Connecticut.\n\n* B02001_001E - Total\n* B02001_002E - White alone\n\nThis is what the `getCensus()` function imported. We now know total and white population per census tract.\n\n----\n\n# Calculating geo disparity\n\nNext, we bring the two dataframes (traffic tickets by census tract and population by census tract) together so we can calculate disparity.\n\n```{r census_cleanup, warning=F, message=F}\n# ok, let's clean this up\nrace_tracts$NAME <- NULL\n\n# Creating a new column for the GEOID that can be joined with the dataframe we already have\nrace_tracts$id <- paste0(race_tracts$state, race_tracts$county, race_tracts$tract)\n\n# Renaming the column names for clarity\ncolnames(race_tracts) <- c(\"state_code\", \"county_code\", \"tract_code\", \"total_pop\", \"white_pop\", \"id\")\n\n# Determining the minority population by subtracting the white population from the total\nrace_tracts$minority_pop <- race_tracts$total_pop - race_tracts$white_pop\n\n# Now figuring out the percent makeup of each census tract\nrace_tracts$white_pop_p <- round(race_tracts$white_pop/race_tracts$total_pop*100,2)\nrace_tracts$minority_pop_p <- round(race_tracts$minority_pop/race_tracts$total_pop*100,2)\n\n# Joining the two datframes\njoined_tracts <- left_join(joined_tracts, race_tracts)\n\n# Calculating disparity between minority traffic stops and population\n\njoined_tracts$min_disp <- joined_tracts$minority_p - joined_tracts$minority_pop_p\n\nkable(head(joined_tracts))\n```\n\n----\n\n# Visualizing geo disparity\n\nFinally, we can visualize this disparity.\n\nThis time, we’ll use a diverging color palette, **PuOr**.\n\n```{r new_map1, fig.width=8, fig.height=5, warning=F, message=F}\nmapping_disparity <- left_join(towntracts, joined_tracts)\nmapping_disparity <- subset(mapping_disparity, !is.na(min_disp))\n\n\npm_ct <- ggplot() \npm_ct <- pm_ct + geom_polygon(data = mapping_disparity, aes(x=long, y=lat, group=group, fill=min_disp/100), color=\"white\", size=.25)\npm_ct <- pm_ct + geom_polygon(data = town_borders, aes(x=long, y=lat, group=group), fill=NA, color = \"black\", size=0.5)\npm_ct <- pm_ct + coord_map() \npm_ct <- pm_ct + scale_fill_distiller(type=\"seq\", trans=\"reverse\", palette = \"PuOr\", label=percent, breaks=pretty_breaks(n=10), name=\"Gap\") \npm_ct <- pm_ct + theme_nothing(legend=TRUE) \npm_ct <- pm_ct + labs(x=NULL, y=NULL, title=\"Hamden: Minority traffic stops versus population\")\npm_ct <- pm_ct + theme(text = element_text(size=15))\npm_ct <- pm_ct + theme(plot.title=element_text(face=\"bold\", hjust=.4))\npm_ct <- pm_ct + theme(plot.subtitle=element_text(face=\"italic\", size=9, margin=margin(l=20)))\npm_ct <- pm_ct + theme(plot.caption=element_text(size=12, margin=margin(t=12), color=\"#7a7d7e\", hjust=0))\npm_ct <- pm_ct + theme(legend.key.size = unit(1, \"cm\"))\nprint(pm_ct)\n```\n\n----\n\n# Add annotations to graphic\n\nWe'll use the `annotate()` function with a combination of segments, points, and text.\n\n```{r new_map2, fig.width=8, fig.height=5, warning=F, message=F}\npm_ct <- ggplot() \npm_ct <- pm_ct + geom_polygon(data = mapping_disparity, aes(x=long, y=lat, group=group, fill=min_disp/100), color=\"white\", size=.25)\npm_ct <- pm_ct + geom_polygon(data = town_borders, aes(x=long, y=lat, group=group), fill=NA, color = \"black\", size=0.5)\npm_ct <- pm_ct + coord_map() \npm_ct <- pm_ct + scale_fill_distiller(type=\"seq\", trans=\"reverse\", palette = \"PuOr\", label=percent, breaks=pretty_breaks(n=10), name=\"Gap\") \npm_ct <- pm_ct + theme_nothing(legend=TRUE) \npm_ct <- pm_ct + labs(x=NULL, y=NULL, title=\"Hamden: Minority traffic stops versus population\")\npm_ct <- pm_ct + theme(text = element_text(size=15))\npm_ct <- pm_ct + theme(plot.title=element_text(face=\"bold\", hjust=.4))\npm_ct <- pm_ct + theme(plot.subtitle=element_text(face=\"italic\", size=9, margin=margin(l=20)))\npm_ct <- pm_ct + theme(plot.caption=element_text(size=12, margin=margin(t=12), color=\"#7a7d7e\", hjust=0))\npm_ct <- pm_ct + theme(legend.key.size = unit(1, \"cm\"))\n\n# Annotations \n\npm_ct <- pm_ct + annotate(\"segment\", x = -72.93, xend = -72.87, y = 41.325, yend = 41.325, colour = \"lightblue\", size=.5) \npm_ct <- pm_ct + annotate(\"point\", x = -72.93, y = 41.325, colour = \"lightblue\", size = 2) \npm_ct <- pm_ct + annotate(\"text\", x = -72.85, y = 41.325, label = \"New Haven\", size=5, colour=\"gray30\") \npm_ct <- pm_ct + annotate(\"segment\", x = -72.89, xend = -72.86, y = 41.375, yend = 41.375, colour = \"lightblue\", size=.5) \npm_ct <- pm_ct + annotate(\"point\", x = -72.89, y = 41.375, colour = \"lightblue\", size = 2) \npm_ct <- pm_ct + annotate(\"text\", x = -72.845, y = 41.375, label = \"Hamden\", size=5, colour=\"gray30\") \npm_ct <- pm_ct + annotate(\"point\", x = -72.83, y = 41.375, colour=\"white\", size=.2) \n\nprint(pm_ct)\n\n```\n\nBeautiful.\n\nCongratulations, you’ve made it.\n\n# Exporting as svg or geojson\n\nOnce again, you can export as a png or svg file. \n\nJust type `ggsave(file=\"filename.svg\", plot=pm_ct, width=10, height=8)`\n\nOr you can save the modified shapefile as a geojson file with the [**geojsonio**](https://cran.r-project.org/web/packages/geojsonio/index.html) package.\n\n```{r export_geo, warning=F, message=F}\n# install.packages(\"geojsonio\")\nlibrary(geojsonio)\n\nmapping_disparity_gj <- geojson_json(mapping_disparity)\ngeojson_write(mapping_disparity_gj)\n```\n\n![myfile.geojson](images/geojson.png)\n\nIt looks like this above.\n\nYou can also simplify the shape if you're dealing with a big file, but we won't get into that now. Here are [some instructions](https://blog.exploratory.io/creating-geojson-out-of-shapefile-in-r-40bc0005857d#.ewza8rcy2) if you're curious, though.\n\nWe can see the census tracts bordering the town of New Haven has the largest disparities. This means there are large gaps between the percent of minorities pulled over in those areas compared to the percent of minorities who actually live there. New Haven has a much higher percent minority population than Hamden and police officers tend to focus their traffic enforcement by there.\n\nYou can also create a quick chart to make the relationship between population and stops more obvious.\n\n# Slope graph for fun\n\n```{r chart, fig.height=7, fig.width=7, warning=F, message=F}\njoined_tracts2 <- subset(joined_tracts, !is.na(minority_p))\nsb1 <- select(joined_tracts2, id, minority_pop_p)\ncolnames(sb1) <- c(\"id\", \"percent\")\nsb1$category <- \"Minority population\"\nsb2 <- select(joined_tracts2, id, minority_p)\ncolnames(sb2) <- c(\"id\", \"percent\")\nsb2$category <- \"Minorities stopped\"\n\nsb3 <- rbind(sb1, sb2)\n\nsp <- ggplot(sb3) \nsp <- sp + geom_line(aes(x=as.factor(category), y=percent, group=id), size=1)\nsp <- sp + geom_point(aes(x=as.factor(category), y=percent), size=3)\nsp <- sp + theme_minimal()\nsp <- sp + scale_y_log10()\nsp <- sp +geom_text(data = subset(sb3, category==\"Minority population\"), \n            aes(x = as.factor(category), y = percent, label = percent), \n            size = 3, hjust = -.7)\nsp <- sp +  geom_text(data = subset(sb3, category==\"Minorities stopped\"), \n            aes(x = as.factor(category), y = percent, label = percent), \n            size = 3, hjust = 1.5) \nsp <- sp+ theme(legend.position = \"none\", \n        panel.grid.major.y = element_blank(),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.x = element_blank(), \n        axis.ticks.y = element_blank(),\n        axis.ticks.x = element_blank(), \n        axis.title.y = element_blank(), \n        axis.text.y = element_blank(), \n        plot.title = element_text(size = 18))  \nsp <- sp + ggtitle(\"Stops in neighborhoods versus residents in Hamden\")\nsp <- sp + xlab(\"\")\nsp\n```\n\n**Next steps?**\n\nPlay around with Census U.S. gazetteer data\n\n* [bhaskarvk.github.io/usgazetteer](https://bhaskarvk.github.io/usgazetteer/)\n* What's a gazetteer? It's a geographical index or dictionary. This one's from [the Census](https://www.census.gov/geo/maps-data/data/gazetteer.html)",
    "created" : 1488241615048.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3097138514",
    "id" : "2CD84778",
    "lastKnownWriteTime" : 1488241897,
    "last_content_update" : 1488241897,
    "path" : "~/Documents/Github/NICAR/2017/maps/mapping-census-data.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}